#include <NewPing.h>
#include <Sonar.h>

#define LEDPIN 10
#define LED_FREQUENCY_HZ 4500
#define LED_HALFPERIOD_US ((1E6 / (LED_FREQUENCY_HZ*2)))

#define AZMPIN 3
#define BASEPULSE_US 20000 // 50 Hz
#define CLOCKWISE_US 1000
#define CNTRCLOCKWISE_US 2000
#define USPERDEGREE 3200
#define SMALLCORRECTION (1.273)

#define US_PER_DEGREE 3.3E3
signed int currentAngle = 0;

#define MAXANGLE 180 // Used in setting current position limits in naming locations
#define MINANGLE 0

#define NUM_OF_BINS (5)
#define WAITTIME_MS (1)
#define NUMSAMPLES (5)
#define ANGLESLICE_DEG ((MAXANGLE-MINANGLE)/NUM_OF_BINS)
#define KILLALLTIME_MS 3000


#define SONARPIN 6
Sonar SONAR1(SONARPIN);
#define NORMAL_RANGE 10000

unsigned long long directionCounter = 0;
unsigned calibrationCounter = 0;
bool countingDown = false;

unsigned long long sampleTimeMark = 0;
unsigned long long killAllTimeMark = 0;
bool incORdec = true;

unsigned int locationCounter = 0;

bool LED_on = false;
/*
   We need to get the switch player values
   One full set up circle
   Rotate
   Sample
   If there is a hit, (already at angle)
   Sound Alarm, Fire 5 seconds
   Check Again,
   Either Continue firing or start search again


*/
enum controlState_t {INIT, CALIBRATION, MOTION, SAMPLE, SOUNDALERT, KILLALL, REST};
controlState_t controlState = INIT;




void setup() {
  pinMode(AZMPIN, OUTPUT);
  pinMode(LEDPIN, OUTPUT);
  initTurret();
  Serial.begin(9600);
  delay(1000);
  SONAR1.reset();
}

// Intializes all the variables
void initTurret()
{
  //  CW_en = false;
  //  CCW_en = false;
  //  LED_en = false;

  //  CWlastPwmEvent = 0;
  //  CCWlastPwmEvent = 0;
  //  LEDlastPwmEvent = 0;
}



void loop() {

  //  goToDegree(0);
  //  delay(1000);
  //  goToDegree(15);
  //  delay(1000);
  //  goToDegree(30);
  //  delay(1000);
  //  goToDegree(45);
  //  delay(1000);
  //  goToDegree(60);
  //  delay(1000);
  //  goToDegree(75);
  //  delay(1000);
  //  goToDegree(90);
  //  delay(1000);

  controlSMtick();

}


void debugStatePrint()
{
  static controlState_t lastState = INIT;

  if (controlState != lastState)
  {
    lastState = controlState;
    Serial.println("CurrentState Is:");
    switch (controlState)
    {
      case INIT:
        Serial.println("INIT");
        break;

      case CALIBRATION:
        Serial.println("CALIBRATION");
        break;

      case MOTION:
        Serial.println("MOTION");
        break;

      case SAMPLE:
        Serial.println("SAMPLE");
        break;

      case SOUNDALERT:
        Serial.println("SOUNDALERT");
        break;

      case KILLALL:
        Serial.println("KILLALL");
        break;

      case REST:
        Serial.println("REST");
        break;

      default:
        Serial.println("default");
    }
  }
}

// Enable LED Strobe
void enableLED()
{
  //LED_en = true;
}

// Disable LED Strobe
void disableLED()
{
  //  LED_en = false;
}

void rotateCW(unsigned long duration)
{
  unsigned long startTime = micros();


  while ( (micros() - startTime) < duration  )
  {
    unsigned long pwmTime = micros();
    // OFF -> ON
    while ((micros() - pwmTime) < CLOCKWISE_US )
    {
      digitalWrite(AZMPIN, HIGH);
    }

    pwmTime = micros();

    while ( (micros() - pwmTime) < (BASEPULSE_US - CLOCKWISE_US) )
    {
      digitalWrite(AZMPIN, LOW);
    }

  }

}

void rotateCCW(unsigned long duration)
{
  unsigned long startTime = micros();


  while ( (micros() - startTime) < duration  )
  {
    unsigned long pwmTime = micros();
    // OFF -> ON
    while ((micros() - pwmTime) < CNTRCLOCKWISE_US )
    {
      digitalWrite(AZMPIN, HIGH);
    }

    pwmTime = micros();

    while ( (micros() - pwmTime) < (BASEPULSE_US - CLOCKWISE_US) )
    {
      digitalWrite(AZMPIN, LOW);
    }

  }
}


///////////////////////////////////////////
// ANGLE CODE
///////////////////////////////////////////


void goToDegree(signed int azm)
{
  //Serial.println("Target Angle");
  //Serial.println(azm);

  // Get the difference
  signed int difference = azm - getCurrentAngle();

  //Serial.println("Difference");
  //Serial.println(difference);

  // If difference is positive,


  if (difference > 0)
  {
    // Rotate  CCW
    if (difference < 180)
    {


      rotateDegCCW(difference);
    } else
    {

      rotateDegCW(360 - difference);
    }
  }

  if (difference < 0)
  {
    // Rotate  CCW
    if (abs(difference) < 180)
    {

      rotateDegCW(abs(difference));
    } else
    {


      rotateDegCCW(360 - abs(difference));
    }
  }
}



// Rotates the given number of degrees
void rotateDegCW(unsigned int azmDeg)
{
  double correction = 1.0;
  if (azmDeg < 20)
  {
    correction = SMALLCORRECTION;
  }

  unsigned long runTime = (azmDeg * US_PER_DEGREE * correction);
  signed int negDelta = -1 * azmDeg;
  updateAngle(negDelta);
  rotateCW(runTime);
}

// Rotates the given number of degrees
void rotateDegCCW(unsigned int azmDeg)
{
  double correction = 1.0;
  if (azmDeg < 20)
  {
    correction = SMALLCORRECTION;
  }

  unsigned long runTime = (azmDeg * US_PER_DEGREE * correction);
  updateAngle(azmDeg);
  rotateCCW(runTime);
}

// Updates the current location of the servo.
// Handles the rollover degrees
// positive deltaDeg is CW
// negative deltaDeg is CCW
void updateAngle(signed int deltaDeg)
{
  currentAngle = currentAngle + deltaDeg;

  // Handle Rollover
  if (currentAngle > MAXANGLE)
  {
    currentAngle = (currentAngle - MAXANGLE) + MINANGLE;
  }
  else if (currentAngle < MINANGLE)
  {
    currentAngle = MAXANGLE - abs(MINANGLE - currentAngle);
  }
  //Serial.println("Current Angle Is:");
  //Serial.println(currentAngle);
}

// Returns the current angular position
signed int getCurrentAngle()
{
  return currentAngle;
}



void controlSMtick()
{
  debugStatePrint();

  switch (controlState)
  {
    case INIT:
      {
        directionCounter = 0;
        sampleTimeMark = 0;
        locationCounter = 0;
        controlState = CALIBRATION;
        incORdec = true;
        calibrationCounter = 0;
        countingDown = false;
      }
      break;

     case CALIBRATION:
     {
        if(calibrationCounter == 0 && countingDown) {
          controlState = MOTION;
        }
        else{
          controlState = CALIBRATION;
        }
        
        signed int angle = (ANGLESLICE_DEG * calibrationCounter);
        goToDegree(angle);
        SONAR1.setNormalRange(calibrationCounter);
        
        if(calibrationCounter == NUM_OF_BINS) {
          countingDown = true;
        }

        //Next calibration counter position
        if(countingDown) {
          --calibrationCounter;
        }
        else{
          ++calibrationCounter;
        }
        break;
     }

    case MOTION:
      {
        signed int angle = (ANGLESLICE_DEG * locationCounter);
        goToDegree(angle);
        controlState = SAMPLE;
        sampleTimeMark = millis();
        //Serial.println("Location");
        //Serial.println(angle);

        delay(WAITTIME_MS);
      }
      break;

    case SAMPLE:
      if (SONAR1.hitDetected(locationCounter)) {
        controlState = SOUNDALERT;
      }
      else {

        controlState = MOTION;
      }
      if (incORdec)
      {
        if ((locationCounter == NUM_OF_BINS))
        {
          
          locationCounter--;
          incORdec = false;
        } else
        {
          locationCounter++;
          incORdec = true;
        }
      }
      else
      {
        if ((locationCounter == 0))
        {
          locationCounter++;
          incORdec = true;
        } else
        {
          locationCounter--;
          incORdec = false;
        }
      }
      break;
    case SOUNDALERT:
      {
        enableLED();
        controlState = KILLALL;
        killAllTimeMark = millis();
      }
      break;
    case KILLALL:
      {
        if ((millis() - killAllTimeMark) >= (KILLALLTIME_MS))
        {
          controlState = MOTION;
        }

      }
      break;

    case REST:
      {

        //disableCW();
        disableLED();
        controlState = MOTION;
      }
      break;
    default:
      {
        controlState = INIT;
      }
      break;

  }
}

